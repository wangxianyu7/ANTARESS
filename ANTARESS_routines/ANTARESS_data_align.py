import numpy as npfrom utils import spec_dopshiftfrom copy import deepcopyimport bindensity as bind'''Aligning profiles '''def align_data(data_exp,rout_mode,nord,dim_exp_resamp,resamp_mode,cen_bins_resamp, edge_bins_resamp,rv_shift_cen,rv_shift_edge = None , nocov = False):    #Shift wavelength tables to a common rest frame    #    - disk-integrated spectra, defined in the observer rest frame, are corrected for the motion of the star relative to the sun (ie the orbital motion of star around the stellar    # system barycenter + systemic velocity) and aligned in the star rest frame    #      intrinsic spectra, defined in the star rest frame, are corrected for the motion of the stellar surface relative to the star rest velocity, and aligned into their local rest frame     #      out-of-transit profiles or aligned intrinsic profiles used as estimates for a given local profile, can be seen as defined in a null rest frame, and shifted back to the stellar surface velocity relative to the star rest velocity    #      atmospheric profiles, defined in the star rest frame, are corrected for the orbital motion of the planet relative to the star rest velocity, and aligned into the planet rest frame      #    - Doppler effect    # nu_received/nu_source = (1 + v_receiver/c )/(1 - v_source/c )     # w_source/w_received   = (1 + v_receiver/c )/(1 - v_source/c )      #      with v_receiver > 0 if receiver moving toward the source    #      with v_source   > 0 if source moving toward the receiver    #      for disk-integrated spectra the source is the star, and the receiver the observer                 #           v_receiver = 0    #           v_source = - rv_star_obs since rv_star_obs < 0 when moving toward us                 #           w_star/w_observer   = (1 + v_observer/c )/(1 - v_star/c )                      #           w_star = w_observer/(1 + rv_star_obs/c )    #           and using the more precise relativistic formula:    #           w_star = w_observer*sqrt(1 - rv_star_obs/c )/sqrt(1 + rv_star_obs/c )                      #    #      for intrinsic spectra the source is the planet-occulted region, and the receiver the star                        #           v_receiver = 0                    #           v_source = - rv_surf_star since rv_surf_star < 0 when moving toward us      #           w_region/w_star   = 1/(1 + rv_surf_star/c )            #           w_region = w_star/(1 + rv_surf_star/c )     #           w_region = w_star*sqrt(1 - rv_surf_star/c )/sqrt(1 + rv_surf_star/c )      #    #      for aligned profiles used as estimate of local profiles, the source can be seen as the star and the receiver the planet-occulted region     #           w_star = w_region/(1 + rv_star_surf/c )      #           w_star = w_region*sqrt(1 - rv_star_surf/c )/sqrt(1 + rv_star_surf/c )     #           w_star = w_region*sqrt(1 - (-rv_surf_star)/c )/sqrt(1 + (-rv_surf_star)/c )     #    #      for atmospheric spectra the source is the planet, and the receiver the star                        #           v_receiver = 0                    #           v_source = - rv_pl_star since rv_pl_star < 0 when moving toward us      #           w_pl/w_star   = 1/(1 + rv_pl_star/c )            #           w_pl = w_star/(1 + rv_pl_star/c )     #           w_pl = w_star*sqrt(1 - rv_pl_star/c )/sqrt(1 + rv_pl_star/c )          if ('spec' in rout_mode):            #Achromatic shift        if (rv_shift_edge is None):            dop_shift = spec_dopshift(rv_shift_cen)             edge_bins_rest = data_exp['edge_bins']*dop_shift            cen_bins_rest = data_exp['cen_bins']*dop_shift                                          #Chromatic shift        #    - in this case the bin edges and center are shifted using the rv calculated at their exact wavelength, to keep the new bins contiguous        else:            edge_bins_rest = data_exp['edge_bins']*spec_dopshift(rv_shift_edge)            cen_bins_rest = data_exp['cen_bins']*spec_dopshift(rv_shift_cen)      #Shift velocity tables to chosen rest frame    #    - for disk-integrated data: RV(M/star) = RV(M/sun) - RV(CDM_star/sun) - RV(star/CDM_star)    #    - for intrinsic data:       RV(M/region) = RV(M/star) - RV(region/star)    #    - for master out data:      RV(M/star) = RV(M/region) + RV(region/star)    #    - for atmospheric data:     RV(M/pl) = RV(M/star) - RV(pl/star)    elif (rout_mode=='CCF'):        edge_bins_rest = data_exp['edge_bins'] - rv_shift_cen        cen_bins_rest = data_exp['cen_bins'] - rv_shift_cen            #----------------------------------------------------------------    #Port data from previous processing    data_align = deepcopy(data_exp)         #Data is resampled on the common table given as input    #    - for spectra we neglect the few bins lost by resampling the data (defined on tables shifted to the star rest frame) on the common table defined in the input rest frame    if cen_bins_resamp is not None:        #Initialize aligned data        data_align['edge_bins']=deepcopy(edge_bins_resamp)        data_align['cen_bins']=deepcopy(cen_bins_resamp)         data_align['flux']=np.zeros(dim_exp_resamp, dtype=float)*np.nan          #Aligning each order        if nocov:            for iord in range(nord):                data_align['flux'][iord] = bind.resampling(data_align['edge_bins'][iord], edge_bins_rest[iord], data_exp['flux'][iord], kind=resamp_mode)                    else:            data_align['cov']=np.zeros(nord, dtype=object)                      for iord in range(nord):                data_align['flux'][iord],data_align['cov'][iord] = bind.resampling(data_align['edge_bins'][iord], edge_bins_rest[iord], data_exp['flux'][iord] , cov = data_exp['cov'][iord], kind=resamp_mode)               #Processing telluric spectrum        if ('tell' in data_exp):            data_align['tell']=np.zeros(dim_exp_resamp, dtype=float)*np.nan            for iord in range(nord):data_align['tell'][iord] = bind.resampling(data_align['edge_bins'][iord], edge_bins_rest[iord], data_exp['tell'][iord], kind=resamp_mode)                            #Processing calibration profile        if ('mean_gdet' in data_exp):            data_align['mean_gdet']=np.zeros(dim_exp_resamp, dtype=float)*np.nan            for iord in range(nord):data_align['mean_gdet'][iord] = bind.resampling(data_align['edge_bins'][iord], edge_bins_rest[iord], data_exp['mean_gdet'][iord], kind=resamp_mode)                                 #Defined bins        data_align['cond_def'] = ~np.isnan(data_align['flux'])     #Data remain defined on independent tables for each exposure    #    - we do not resample the data tables of each exposure and keep them defined on their shifted spectral tables    else:              data_align['cen_bins'] = cen_bins_rest           data_align['edge_bins'] = edge_bins_rest                    return data_align